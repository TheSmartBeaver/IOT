/**
 * Generated by anjay_codegen.py on 2021-02-21 15:53:13
 *
 * LwM2M Object: Presence
 * ID: 3302, URN: urn:oma:lwm2m:ext:3302:1.1, Optional, Multiple
 *
 * Presence sensor with digital sensing, optional delay parameters
 */
#include <assert.h>
#include <stdbool.h>

#include <anjay/anjay.h>
#include <avsystem/commons/avs_defs.h>
#include <avsystem/commons/avs_list.h>
#include <avsystem/commons/avs_memory.h>

/**
 * Digital Input State: R, Single, Mandatory
 * type: boolean, range: N/A, unit: N/A
 * The current state of a digital input.
 */
#define RID_DIGITAL_INPUT_STATE 5500

/**
 * Digital Input Counter: R, Single, Optional
 * type: integer, range: N/A, unit: N/A
 * The cumulative value of active state detected.
 */
#define RID_DIGITAL_INPUT_COUNTER 5501

/**
 * Digital Input Counter Reset: E, Single, Optional
 * type: N/A, range: N/A, unit: N/A
 * Reset the Counter value.
 */
#define RID_DIGITAL_INPUT_COUNTER_RESET 5505

/**
 * Timestamp: R, Single, Optional
 * type: time, range: N/A, unit: N/A
 * The timestamp of when the measurement was performed.
 */
#define RID_TIMESTAMP 5518

/**
 * Application Type: RW, Single, Optional
 * type: string, range: N/A, unit: N/A
 * The application type of the sensor or actuator as a string depending
 * on the use case.
 */
#define RID_APPLICATION_TYPE 5750

/**
 * Sensor Type: R, Single, Optional
 * type: string, range: N/A, unit: N/A
 * The type of the sensor (for instance PIR type).
 */
#define RID_SENSOR_TYPE 5751

/**
 * Busy to Clear delay: RW, Single, Optional
 * type: integer, range: N/A, unit: ms
 * Delay from the detection state to the clear state in ms.
 */
#define RID_BUSY_TO_CLEAR_DELAY 5903

/**
 * Clear to Busy delay: RW, Single, Optional
 * type: integer, range: N/A, unit: ms
 * Delay from the clear state to the busy state in ms.
 */
#define RID_CLEAR_TO_BUSY_DELAY 5904

/**
 * Measurement Quality Indicator: R, Single, Optional
 * type: integer, range: 0..23, unit: N/A
 * Measurement quality indicator reported by a smart sensor. 0: UNCHECKED
 * No quality checks were done because they do not exist or can not be
 * applied. 1: REJECTED WITH CERTAINTY The measured value is invalid. 2:
 * REJECTED WITH PROBABILITY The measured value is likely invalid. 3:
 * ACCEPTED BUT SUSPICIOUS The measured value is likely OK. 4: ACCEPTED
 * The measured value is OK. 5-15: Reserved for future extensions. 16-23:
 * Vendor specific measurement quality.
 */
#define RID_MEASUREMENT_QUALITY_INDICATOR 6042

/**
 * Measurement Quality Level: R, Single, Optional
 * type: integer, range: 0..100, unit: N/A
 * Measurement quality level reported by a smart sensor. Quality level
 * 100 means that the measurement has fully passed quality check
 * algorithms. Smaller quality levels mean that quality has decreased and
 * the measurement has only partially passed quality check algorithms.
 * The smaller the quality level, the more caution should be used by the
 * application when using the measurement. When the quality level is 0 it
 * means that the measurement should certainly be rejected.
 */
#define RID_MEASUREMENT_QUALITY_LEVEL 6049

/**
 * Fractional Timestamp: R, Single, Optional
 * type: float, range: 0..1, unit: s
 * Fractional part of the timestamp when sub-second precision is used
 * (e.g., 0.23 for 230 ms).
 */
#define RID_FRACTIONAL_TIMESTAMP 6050

typedef struct presence_instance_struct {
    anjay_iid_t iid;

    // TODO: instance state
} presence_instance_t;

typedef struct presence_object_struct {
    const anjay_dm_object_def_t *def;
    AVS_LIST(presence_instance_t) instances;

    // TODO: object state
} presence_object_t;

static inline presence_object_t *
get_obj(const anjay_dm_object_def_t *const *obj_ptr) {
    assert(obj_ptr);
    return AVS_CONTAINER_OF(obj_ptr, presence_object_t, def);
}

static presence_instance_t *find_instance(const presence_object_t *obj,
                                          anjay_iid_t iid) {
    AVS_LIST(presence_instance_t) it;
    AVS_LIST_FOREACH(it, obj->instances) {
        if (it->iid == iid) {
            return it;
        } else if (it->iid > iid) {
            break;
        }
    }

    return NULL;
}

static int list_instances(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_dm_list_ctx_t *ctx) {
    (void) anjay;

    AVS_LIST(presence_instance_t) it;
    AVS_LIST_FOREACH(it, get_obj(obj_ptr)->instances) {
        anjay_dm_emit(ctx, it->iid);
    }

    return 0;
}

static int init_instance(presence_instance_t *inst, anjay_iid_t iid) {
    assert(iid != ANJAY_ID_INVALID);

    inst->iid = iid;
    // TODO: instance init

    // TODO: return 0 on success, negative value on failure
    return 0;
}

static void release_instance(presence_instance_t *inst) {
    // TODO: instance cleanup
    (void) inst;
}

static presence_instance_t *
add_instance(presence_object_t *obj, anjay_iid_t iid) {
    assert(find_instance(obj, iid) == NULL);

    AVS_LIST(presence_instance_t) created =
            AVS_LIST_NEW_ELEMENT(presence_instance_t);
    if (!created) {
        return NULL;
    }

    int result = init_instance(created, iid);
    if (result) {
        AVS_LIST_CLEAR(&created);
        return NULL;
    }

    AVS_LIST(presence_instance_t) *ptr;
    AVS_LIST_FOREACH_PTR(ptr, &obj->instances) {
        if ((*ptr)->iid > created->iid) {
            break;
        }
    }

    AVS_LIST_INSERT(ptr, created);
    return created;
}

static int instance_create(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void) anjay;
    presence_object_t *obj = get_obj(obj_ptr);
    assert(obj);

    return add_instance(obj, iid) ? 0 : ANJAY_ERR_INTERNAL;
}

static int instance_remove(anjay_t *anjay,
                           const anjay_dm_object_def_t *const *obj_ptr,
                           anjay_iid_t iid) {
    (void) anjay;
    presence_object_t *obj = get_obj(obj_ptr);
    assert(obj);

    AVS_LIST(presence_instance_t) *it;
    AVS_LIST_FOREACH_PTR(it, &obj->instances) {
        if ((*it)->iid == iid) {
            release_instance(*it);
            AVS_LIST_DELETE(it);
            return 0;
        } else if ((*it)->iid > iid) {
            break;
        }
    }

    assert(0);
    return ANJAY_ERR_NOT_FOUND;
}

static int instance_reset(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid) {
    (void) anjay;

    presence_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    presence_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    // TODO: instance reset
    return 0;
}

static int list_resources(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_dm_resource_list_ctx_t *ctx) {
    (void) anjay;
    (void) obj_ptr;
    (void) iid;

    anjay_dm_emit_res(ctx, RID_DIGITAL_INPUT_STATE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_DIGITAL_INPUT_COUNTER,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_DIGITAL_INPUT_COUNTER_RESET,
                      ANJAY_DM_RES_E, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_TIMESTAMP,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_APPLICATION_TYPE,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_SENSOR_TYPE,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_BUSY_TO_CLEAR_DELAY,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_CLEAR_TO_BUSY_DELAY,
                      ANJAY_DM_RES_RW, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MEASUREMENT_QUALITY_INDICATOR,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_MEASUREMENT_QUALITY_LEVEL,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    anjay_dm_emit_res(ctx, RID_FRACTIONAL_TIMESTAMP,
                      ANJAY_DM_RES_R, ANJAY_DM_RES_PRESENT);
    return 0;
}

static int resource_read(anjay_t *anjay,
                         const anjay_dm_object_def_t *const *obj_ptr,
                         anjay_iid_t iid,
                         anjay_rid_t rid,
                         anjay_riid_t riid,
                         anjay_output_ctx_t *ctx) {
    (void) anjay;

    presence_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    presence_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_DIGITAL_INPUT_STATE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_bool(ctx, 0); // TODO

    case RID_DIGITAL_INPUT_COUNTER:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_TIMESTAMP:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i64(ctx, 0); // TODO

    case RID_APPLICATION_TYPE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_SENSOR_TYPE:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_string(ctx, ""); // TODO

    case RID_BUSY_TO_CLEAR_DELAY:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_CLEAR_TO_BUSY_DELAY:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_MEASUREMENT_QUALITY_INDICATOR:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_MEASUREMENT_QUALITY_LEVEL:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_i32(ctx, 0); // TODO

    case RID_FRACTIONAL_TIMESTAMP:
        assert(riid == ANJAY_ID_INVALID);
        return anjay_ret_float(ctx, 0); // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_write(anjay_t *anjay,
                          const anjay_dm_object_def_t *const *obj_ptr,
                          anjay_iid_t iid,
                          anjay_rid_t rid,
                          anjay_riid_t riid,
                          anjay_input_ctx_t *ctx) {
    (void) anjay;

    presence_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    presence_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_APPLICATION_TYPE: {
        assert(riid == ANJAY_ID_INVALID);
        char value[256]; // TODO
        return anjay_get_string(ctx, value, sizeof(value)); // TODO
    }

    case RID_BUSY_TO_CLEAR_DELAY: {
        assert(riid == ANJAY_ID_INVALID);
        int32_t value; // TODO
        return anjay_get_i32(ctx, &value); // TODO
    }

    case RID_CLEAR_TO_BUSY_DELAY: {
        assert(riid == ANJAY_ID_INVALID);
        int32_t value; // TODO
        return anjay_get_i32(ctx, &value); // TODO
    }

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static int resource_execute(anjay_t *anjay,
                            const anjay_dm_object_def_t *const *obj_ptr,
                            anjay_iid_t iid,
                            anjay_rid_t rid,
                            anjay_execute_ctx_t *arg_ctx) {
    (void) arg_ctx;

    presence_object_t *obj = get_obj(obj_ptr);
    assert(obj);
    presence_instance_t *inst = find_instance(obj, iid);
    assert(inst);

    switch (rid) {
    case RID_DIGITAL_INPUT_COUNTER_RESET:
        return ANJAY_ERR_NOT_IMPLEMENTED; // TODO

    default:
        return ANJAY_ERR_METHOD_NOT_ALLOWED;
    }
}

static const anjay_dm_object_def_t OBJ_DEF = {
    .oid = 3302,
    .handlers = {
        .list_instances = list_instances,
        .instance_create = instance_create,
        .instance_remove = instance_remove,
        .instance_reset = instance_reset,

        .list_resources = list_resources,
        .resource_read = resource_read,
        .resource_write = resource_write,
        .resource_execute = resource_execute,

        // TODO: implement these if transactional write/create is required
        .transaction_begin = anjay_dm_transaction_NOOP,
        .transaction_validate = anjay_dm_transaction_NOOP,
        .transaction_commit = anjay_dm_transaction_NOOP,
        .transaction_rollback = anjay_dm_transaction_NOOP
    }
};

const anjay_dm_object_def_t **presence_object_create(void) {
    presence_object_t *obj = (presence_object_t *) avs_calloc(1, sizeof(presence_object_t));
    if (!obj) {
        return NULL;
    }
    obj->def = &OBJ_DEF;

    // TODO: object init

    return &obj->def;
}

void presence_object_release(const anjay_dm_object_def_t **def) {
    if (def) {
        presence_object_t *obj = get_obj(def);
        AVS_LIST_CLEAR(&obj->instances) {
            release_instance(obj->instances);
        }

        // TODO: object cleanup

        avs_free(obj);
    }
}
